{"mappings":"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","sources":["<anon>","src/modules/Game.class.js","src/scripts/main.js"],"sourcesContent":["\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire7b01\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire7b01\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"efyfk\", function(module, exports) {\n/* eslint-disable indent */ \"use strict\";\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */ class $a5fd07fa01589658$var$Game {\n    /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */ // Default game fiels is 4x4\n    constructor(initialCustomState){\n        // declare constants\n        this.direction = {\n            up: \"up\",\n            down: \"down\",\n            left: \"left\",\n            right: \"right\"\n        };\n        this.gameStatus = {\n            idle: \"idle\",\n            playing: \"playing\",\n            win: \"win\",\n            lose: \"lose\"\n        };\n        this.initialField = [\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ]\n        ];\n        this.score = 0;\n        this.cellMax = 0;\n        this.fieldSize = 4;\n        this.isAvailableMovement = true;\n        this.status = this.gameStatus.idle;\n        this.isCustomInitial = !!initialCustomState;\n        this.defaultState = initialCustomState || this.initialField;\n    }\n    moveLeft() {\n        this.status = this.gameStatus.playing;\n        this.sumGameFieldByRow(this.direction.left);\n    }\n    moveRight() {\n        this.status = this.gameStatus.playing;\n        this.sumGameFieldByRow(this.direction.right);\n    }\n    moveUp() {\n        this.status = this.gameStatus.playing;\n        this.sumGameFieldByColumn(this.direction.up);\n    }\n    moveDown() {\n        this.status = this.gameStatus.playing;\n        this.sumGameFieldByColumn(this.direction.down);\n    }\n    /**\n   * @returns {number}\n   */ getScore() {\n        return this.score;\n    }\n    /**\n   * @returns {number[][]}\n   */ getState() {\n        return this.state;\n    }\n    /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */ getStatus() {\n        return this.status;\n    }\n    /**\n   * Starts the game.\n   */ start() {\n        this.state = this.isCustomInitial && this.initialCustomState.length === this.fieldSize ? this.initialCustomState : this.initialField;\n        this.status = this.gameStatus.playing;\n        this.generateRandomCellOnField(2);\n    }\n    /**\n   * Resets the game.\n   */ restart() {\n        if (this.isCustomInitial) this.state = this.defaultState;\n        else {\n            this.state = this.initialField;\n            this.generateRandomCellOnField(2);\n        }\n        this.score = 0;\n        this.status = this.gameStatus.idle;\n    }\n    /**\n   * Get cell's max value.\n   */ gMaxCell() {\n        return this.cellMax;\n    }\n    /**\n   * Get if cells can move.\n   */ getMoveAvailability() {\n        return this.isAvailableMovement;\n    }\n    // helpers\n    getMaxValueCell(gameField) {\n        return Math.max(...gameField.flat());\n    }\n    getRandomCellValue() {\n        return Math.random() < 0.9 ? 2 : 4;\n    }\n    getRandomCellIndex(gameFieldSize = this.fieldSize) {\n        const row = Math.floor(Math.random() * gameFieldSize);\n        const col = Math.floor(Math.random() * gameFieldSize);\n        return {\n            row: row,\n            col: col\n        };\n    }\n    sumRow(row, size = this.fieldSize, rtl = true) {\n        // right to left (rtl or TRUE) represent summ cell with RIGHT or DOWN click\n        // left to right (ltr or FALSE) represent summ cell with LEFT or UP click\n        let isSumm = false;\n        let sum = 0;\n        if (rtl) {\n            const rightToLeftSum = row.reduceRight((newRow, value, i)=>{\n                if (!value) return newRow;\n                const firstValue = newRow[0];\n                if (value === firstValue && !isSumm) {\n                    isSumm = true;\n                    sum = firstValue * 2;\n                    return [\n                        firstValue * 2,\n                        ...newRow.slice(1)\n                    ];\n                }\n                return [\n                    value,\n                    ...newRow\n                ];\n            }, []);\n            const rowWithCollapsedRtl = rightToLeftSum.length === 4 ? rightToLeftSum : [\n                ...new Array(size - rightToLeftSum.length).fill(0),\n                ...rightToLeftSum\n            ];\n            return {\n                row: rowWithCollapsedRtl,\n                summCollapsed: sum\n            };\n        }\n        const leftToRightSum = row.reduce((newRow, value, i)=>{\n            if (!value) return newRow;\n            if (i === 0) {\n                newRow.push(value);\n                return newRow;\n            }\n            if (value === newRow[newRow.length - 1] && !isSumm) {\n                isSumm = true;\n                sum = newRow.slice(-1) * 2;\n                return [\n                    ...newRow.slice(0, -1),\n                    newRow.slice(-1) * 2\n                ];\n            }\n            return [\n                ...newRow,\n                value\n            ];\n        }, []);\n        const rowWithCollapsedLtr = leftToRightSum.length === 4 ? leftToRightSum : [\n            ...leftToRightSum,\n            ...new Array(size - leftToRightSum.length).fill(0)\n        ];\n        return {\n            row: rowWithCollapsedLtr,\n            summCollapsed: sum\n        };\n    }\n    transposeField(field) {\n        const transposedField = field.reduce((newArr, row)=>{\n            row.forEach((item, itemIdx)=>{\n                newArr[itemIdx] = [\n                    ...newArr[itemIdx] || [],\n                    item\n                ];\n            });\n            return newArr;\n        }, []);\n        return transposedField;\n    }\n    compareGameField(array1, array2) {\n        const array1Json = JSON.stringify(array1);\n        const array2Json = JSON.stringify(array2);\n        return array1Json === array2Json;\n    }\n    getAvailabilityMovement(field) {\n        let sumOfCollapsedCells = 0;\n        // check for free cells\n        const hasFreeCell = field.flat().includes(0);\n        if (hasFreeCell) return true;\n        // check availablityt for left or right movement\n        field.forEach((row)=>{\n            const { summCollapsed: leftCollapsed } = this.sumRow(row, this.fieldSize, this.direction.left);\n            const { summCollapsed: rightCollapsed } = this.sumRow(row, this.fieldSize, this.direction.right);\n            sumOfCollapsedCells += leftCollapsed + rightCollapsed;\n        });\n        // check availablity for up or down movement\n        const tr = this.transposeField(field);\n        tr.forEach((row)=>{\n            const { summCollapsed: upCollapsed } = this.sumRow(row, this.fieldSize, this.direction.up);\n            const { summCollapsed: downCollapsed } = this.sumRow(row, this.fieldSize, this.direction.down);\n            sumOfCollapsedCells += upCollapsed + downCollapsed;\n        });\n        return sumOfCollapsedCells > 0;\n    }\n    // game logic methods\n    sumGameFieldByRow(direction) {\n        const gameField = this.state;\n        const size = this.fieldSize;\n        let scoreByField = this.score || 0;\n        const calculatedGameField = gameField.map((row)=>{\n            const { row: rowCollaped, summCollapsed: summCollapsed } = this.sumRow(row, size, // eslint-disable-next-line no-unneeded-ternary\n            direction === this.direction.right ? true : false);\n            scoreByField += summCollapsed;\n            return rowCollaped;\n        });\n        const isGameFieldChanged = !this.compareGameField(gameField, calculatedGameField);\n        if (!isGameFieldChanged) return;\n        this.score = scoreByField;\n        this.state = calculatedGameField;\n        this.cellMax = this.getMaxValueCell(calculatedGameField);\n        this.generateRandomCellOnField();\n    }\n    sumGameFieldByColumn(direction) {\n        const gameField = this.state;\n        const size = this.fieldSize;\n        let scoreByField = this.score || 0;\n        const calculatedGameField = this.transposeField(gameField).map((row)=>{\n            const { row: rowCollaped, summCollapsed: summCollapsed } = this.sumRow(row, size, // eslint-disable-next-line no-unneeded-ternary\n            direction === this.direction.down ? true : false);\n            scoreByField += summCollapsed;\n            return rowCollaped;\n        });\n        const isGameFieldChanged = !this.compareGameField(gameField, calculatedGameField);\n        if (!isGameFieldChanged) return;\n        this.score = scoreByField;\n        this.state = this.transposeField(calculatedGameField);\n        this.cellMax = this.getMaxValueCell(calculatedGameField);\n        this.generateRandomCellOnField();\n    }\n    generateRandomCellOnField(qty = 1) {\n        const gameField = JSON.parse(JSON.stringify(this.state));\n        for(let i = 0; i < qty; i++){\n            let cell = this.getRandomCellIndex();\n            const cellValue = this.getRandomCellValue();\n            while(gameField[cell.row][cell.col])cell = this.getRandomCellIndex();\n            gameField[cell.row][cell.col] = cellValue;\n        }\n        this.state = gameField;\n        this.isAvailableMovement = this.getAvailabilityMovement(gameField);\n    }\n}\nmodule.exports = $a5fd07fa01589658$var$Game;\n\n});\n\n\"use strict\";\n\ndocument.addEventListener(\"DOMContentLoaded\", ()=>{\n    const Game = (parcelRequire(\"efyfk\"));\n    const game = new Game();\n    const startRestartButton = document.querySelector(\".button\");\n    const gStatus = ()=>game.getStatus();\n    const gState = ()=>game.getState();\n    const gScore = ()=>game.getScore();\n    const gMaxCell = ()=>game.gMaxCell();\n    const gIsAvailableMovement = ()=>game.getMoveAvailability();\n    const messageStart = document.querySelector(\".message-start\");\n    const messageWin = document.querySelector(\".message-win\");\n    const messageLose = document.querySelector(\".message-lose\");\n    const gameScore = document.querySelector(\".game-score\");\n    // #region create game field cells array\n    const rows = document.querySelectorAll(\".field-row\");\n    const gameFieldCells = [];\n    rows.forEach((row)=>{\n        gameFieldCells.push(row.querySelectorAll(\".field-cell\"));\n    });\n    // #endregion\n    // #region clear game field\n    const resetGame = ()=>{\n        game.restart();\n        refreshGameField();\n        messageWin.classList.add(\"hidden\");\n        messageLose.classList.add(\"hidden\");\n    };\n    // #endregion\n    // #region change start/restart button text and class\n    const changeButtonStartToRestart = ()=>{\n        startRestartButton.classList.remove(\"start\");\n        startRestartButton.classList.add(\"restart\");\n        startRestartButton.textContent = \"Restart\";\n    };\n    const changeButtonRestartToStart = ()=>{\n        startRestartButton.classList.remove(\"restart\");\n        startRestartButton.classList.add(\"start\");\n        startRestartButton.textContent = \"Start\";\n    };\n    // #endregion\n    // #region refreshGameField\n    const refreshGameField = ()=>{\n        const field = gState();\n        const maxCell = gMaxCell();\n        const isAvailableMovement = gIsAvailableMovement();\n        gameScore.textContent = gScore();\n        for(let i = 0; i < gameFieldCells.length; i++){\n            const row = gameFieldCells[i];\n            for(let k = 0; k < row.length; k++){\n                const value = field[i][k];\n                const cell = row[k];\n                cell.textContent = \"\";\n                cell.className = \"field-cell\";\n                if (value) {\n                    cell.textContent = value;\n                    cell.className = `field-cell field-cell--${value}`;\n                }\n            }\n        }\n        if (maxCell === 2048) {\n            document.removeEventListener(\"keydown\", kbListener);\n            messageWin.classList.remove(\"hidden\");\n        }\n        if (!isAvailableMovement) {\n            document.removeEventListener(\"keydown\", kbListener);\n            messageLose.classList.remove(\"hidden\");\n        }\n    };\n    // #endregion\n    // #region keyboardListener\n    const kbListener = (e)=>{\n        if (gStatus() === \"playing\") changeButtonStartToRestart();\n        switch(e.key){\n            case \"ArrowLeft\":\n                game.moveLeft();\n                refreshGameField();\n                break;\n            case \"ArrowRight\":\n                game.moveRight();\n                refreshGameField();\n                break;\n            case \"ArrowUp\":\n                game.moveUp();\n                refreshGameField();\n                break;\n            case \"ArrowDown\":\n                game.moveDown();\n                refreshGameField();\n                break;\n            default:\n                break;\n        }\n    };\n    // #endregion\n    startRestartButton.addEventListener(\"click\", (e)=>{\n        e.preventDefault();\n        const isResetButton = e.target.classList.contains(\"restart\");\n        const isStartButton = e.target.classList.contains(\"start\");\n        if (gStatus() === \"playing\" && isResetButton) {\n            resetGame();\n            changeButtonRestartToStart();\n            document.addEventListener(\"keydown\", kbListener);\n        }\n        if (gStatus() === \"playing\" && isStartButton) {\n            resetGame();\n            refreshGameField();\n        }\n        if (gStatus() === \"idle\" && isStartButton) {\n            game.start();\n            e.currentTarget.blur();\n            messageStart.classList.add(\"hidden\");\n            refreshGameField();\n            document.addEventListener(\"keydown\", kbListener);\n        }\n    });\n});\n\n\n//# sourceMappingURL=index.b3e4f9bc.js.map\n","/* eslint-disable indent */\n'use strict';\n\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */\nclass Game {\n  /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */\n\n  // Default game fiels is 4x4\n\n  constructor(initialCustomState) {\n    // declare constants\n    this.direction = {\n      up: 'up',\n      down: 'down',\n      left: 'left',\n      right: 'right',\n    };\n\n    this.gameStatus = {\n      idle: 'idle',\n      playing: 'playing',\n      win: 'win',\n      lose: 'lose',\n    };\n\n    this.initialField = [\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n    ];\n\n    this.score = 0;\n    this.cellMax = 0;\n    this.fieldSize = 4;\n    this.isAvailableMovement = true;\n    this.status = this.gameStatus.idle;\n    this.isCustomInitial = !!initialCustomState;\n    this.defaultState = initialCustomState || this.initialField;\n  }\n\n  moveLeft() {\n    this.status = this.gameStatus.playing;\n    this.sumGameFieldByRow(this.direction.left);\n  }\n\n  moveRight() {\n    this.status = this.gameStatus.playing;\n    this.sumGameFieldByRow(this.direction.right);\n  }\n\n  moveUp() {\n    this.status = this.gameStatus.playing;\n    this.sumGameFieldByColumn(this.direction.up);\n  }\n\n  moveDown() {\n    this.status = this.gameStatus.playing;\n    this.sumGameFieldByColumn(this.direction.down);\n  }\n\n  /**\n   * @returns {number}\n   */\n  getScore() {\n    return this.score;\n  }\n\n  /**\n   * @returns {number[][]}\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */\n  getStatus() {\n    return this.status;\n  }\n\n  /**\n   * Starts the game.\n   */\n  start() {\n    this.state =\n      this.isCustomInitial && this.initialCustomState.length === this.fieldSize\n        ? this.initialCustomState\n        : this.initialField;\n    this.status = this.gameStatus.playing;\n\n    this.generateRandomCellOnField(2);\n  }\n\n  /**\n   * Resets the game.\n   */\n  restart() {\n    if (this.isCustomInitial) {\n      this.state = this.defaultState;\n    } else {\n      this.state = this.initialField;\n      this.generateRandomCellOnField(2);\n    }\n\n    this.score = 0;\n    this.status = this.gameStatus.idle;\n  }\n\n  /**\n   * Get cell's max value.\n   */\n\n  gMaxCell() {\n    return this.cellMax;\n  }\n\n  /**\n   * Get if cells can move.\n   */\n\n  getMoveAvailability() {\n    return this.isAvailableMovement;\n  }\n\n  // helpers\n\n  getMaxValueCell(gameField) {\n    return Math.max(...gameField.flat());\n  }\n\n  getRandomCellValue() {\n    return Math.random() < 0.9 ? 2 : 4;\n  }\n\n  getRandomCellIndex(gameFieldSize = this.fieldSize) {\n    const row = Math.floor(Math.random() * gameFieldSize);\n    const col = Math.floor(Math.random() * gameFieldSize);\n\n    return { row, col };\n  }\n\n  sumRow(row, size = this.fieldSize, rtl = true) {\n    // right to left (rtl or TRUE) represent summ cell with RIGHT or DOWN click\n    // left to right (ltr or FALSE) represent summ cell with LEFT or UP click\n\n    let isSumm = false;\n    let sum = 0;\n\n    if (rtl) {\n      const rightToLeftSum = row.reduceRight((newRow, value, i) => {\n        if (!value) {\n          return newRow;\n        }\n\n        const firstValue = newRow[0];\n\n        if (value === firstValue && !isSumm) {\n          isSumm = true;\n          sum = firstValue * 2;\n\n          return [firstValue * 2, ...newRow.slice(1)];\n        }\n\n        return [value, ...newRow];\n      }, []);\n\n      const rowWithCollapsedRtl =\n        rightToLeftSum.length === 4\n          ? rightToLeftSum\n          : [\n              ...new Array(size - rightToLeftSum.length).fill(0),\n              ...rightToLeftSum,\n            ];\n\n      return {\n        row: rowWithCollapsedRtl,\n        summCollapsed: sum,\n      };\n    }\n\n    const leftToRightSum = row.reduce((newRow, value, i) => {\n      if (!value) {\n        return newRow;\n      }\n\n      if (i === 0) {\n        newRow.push(value);\n\n        return newRow;\n      }\n\n      if (value === newRow[newRow.length - 1] && !isSumm) {\n        isSumm = true;\n        sum = newRow.slice(-1) * 2;\n\n        return [...newRow.slice(0, -1), newRow.slice(-1) * 2];\n      }\n\n      return [...newRow, value];\n    }, []);\n\n    const rowWithCollapsedLtr =\n      leftToRightSum.length === 4\n        ? leftToRightSum\n        : [\n            ...leftToRightSum,\n            ...new Array(size - leftToRightSum.length).fill(0),\n          ];\n\n    return {\n      row: rowWithCollapsedLtr,\n      summCollapsed: sum,\n    };\n  }\n\n  transposeField(field) {\n    const transposedField = field.reduce((newArr, row) => {\n      row.forEach((item, itemIdx) => {\n        newArr[itemIdx] = [...(newArr[itemIdx] || []), item];\n      });\n\n      return newArr;\n    }, []);\n\n    return transposedField;\n  }\n\n  compareGameField(array1, array2) {\n    const array1Json = JSON.stringify(array1);\n    const array2Json = JSON.stringify(array2);\n\n    return array1Json === array2Json;\n  }\n\n  getAvailabilityMovement(field) {\n    let sumOfCollapsedCells = 0;\n\n    // check for free cells\n\n    const hasFreeCell = field.flat().includes(0);\n\n    if (hasFreeCell) {\n      return true;\n    }\n\n    // check availablityt for left or right movement\n    field.forEach((row) => {\n      const { summCollapsed: leftCollapsed } = this.sumRow(\n        row,\n        this.fieldSize,\n        this.direction.left,\n      );\n      const { summCollapsed: rightCollapsed } = this.sumRow(\n        row,\n        this.fieldSize,\n        this.direction.right,\n      );\n\n      sumOfCollapsedCells += leftCollapsed + rightCollapsed;\n    });\n\n    // check availablity for up or down movement\n\n    const tr = this.transposeField(field);\n\n    tr.forEach((row) => {\n      const { summCollapsed: upCollapsed } = this.sumRow(\n        row,\n        this.fieldSize,\n        this.direction.up,\n      );\n      const { summCollapsed: downCollapsed } = this.sumRow(\n        row,\n        this.fieldSize,\n        this.direction.down,\n      );\n\n      sumOfCollapsedCells += upCollapsed + downCollapsed;\n    });\n\n    return sumOfCollapsedCells > 0;\n  }\n\n  // game logic methods\n\n  sumGameFieldByRow(direction) {\n    const gameField = this.state;\n    const size = this.fieldSize;\n    let scoreByField = this.score || 0;\n\n    const calculatedGameField = gameField.map((row) => {\n      const { row: rowCollaped, summCollapsed } = this.sumRow(\n        row,\n        size,\n        // eslint-disable-next-line no-unneeded-ternary\n        direction === this.direction.right ? true : false,\n      );\n\n      scoreByField += summCollapsed;\n\n      return rowCollaped;\n    });\n\n    const isGameFieldChanged = !this.compareGameField(\n      gameField,\n      calculatedGameField,\n    );\n\n    if (!isGameFieldChanged) {\n      return;\n    }\n\n    this.score = scoreByField;\n    this.state = calculatedGameField;\n    this.cellMax = this.getMaxValueCell(calculatedGameField);\n    this.generateRandomCellOnField();\n  }\n\n  sumGameFieldByColumn(direction) {\n    const gameField = this.state;\n    const size = this.fieldSize;\n    let scoreByField = this.score || 0;\n\n    const calculatedGameField = this.transposeField(gameField).map((row) => {\n      const { row: rowCollaped, summCollapsed } = this.sumRow(\n        row,\n        size,\n        // eslint-disable-next-line no-unneeded-ternary\n        direction === this.direction.down ? true : false,\n      );\n\n      scoreByField += summCollapsed;\n\n      return rowCollaped;\n    });\n\n    const isGameFieldChanged = !this.compareGameField(\n      gameField,\n      calculatedGameField,\n    );\n\n    if (!isGameFieldChanged) {\n      return;\n    }\n\n    this.score = scoreByField;\n    this.state = this.transposeField(calculatedGameField);\n    this.cellMax = this.getMaxValueCell(calculatedGameField);\n    this.generateRandomCellOnField();\n  }\n\n  generateRandomCellOnField(qty = 1) {\n    const gameField = JSON.parse(JSON.stringify(this.state));\n\n    for (let i = 0; i < qty; i++) {\n      let cell = this.getRandomCellIndex();\n      const cellValue = this.getRandomCellValue();\n\n      while (gameField[cell.row][cell.col]) {\n        cell = this.getRandomCellIndex();\n      }\n\n      gameField[cell.row][cell.col] = cellValue;\n    }\n    this.state = gameField;\n\n    this.isAvailableMovement = this.getAvailabilityMovement(gameField);\n  }\n}\n\nmodule.exports = Game;\n","'use strict';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const Game = require('../modules/Game.class');\n  const game = new Game();\n  const startRestartButton = document.querySelector('.button');\n  const gStatus = () => game.getStatus();\n  const gState = () => game.getState();\n  const gScore = () => game.getScore();\n  const gMaxCell = () => game.gMaxCell();\n  const gIsAvailableMovement = () => game.getMoveAvailability();\n  const messageStart = document.querySelector('.message-start');\n  const messageWin = document.querySelector('.message-win');\n  const messageLose = document.querySelector('.message-lose');\n  const gameScore = document.querySelector('.game-score');\n\n  // #region create game field cells array\n  const rows = document.querySelectorAll('.field-row');\n  const gameFieldCells = [];\n\n  rows.forEach((row) => {\n    gameFieldCells.push(row.querySelectorAll('.field-cell'));\n  });\n  // #endregion\n\n  // #region clear game field\n  const resetGame = () => {\n    game.restart();\n    refreshGameField();\n    messageWin.classList.add('hidden');\n    messageLose.classList.add('hidden');\n  };\n  // #endregion\n\n  // #region change start/restart button text and class\n  const changeButtonStartToRestart = () => {\n    startRestartButton.classList.remove('start');\n    startRestartButton.classList.add('restart');\n    startRestartButton.textContent = 'Restart';\n  };\n\n  const changeButtonRestartToStart = () => {\n    startRestartButton.classList.remove('restart');\n    startRestartButton.classList.add('start');\n    startRestartButton.textContent = 'Start';\n  };\n\n  // #endregion\n\n  // #region refreshGameField\n\n  const refreshGameField = () => {\n    const field = gState();\n    const maxCell = gMaxCell();\n    const isAvailableMovement = gIsAvailableMovement();\n\n    gameScore.textContent = gScore();\n\n    for (let i = 0; i < gameFieldCells.length; i++) {\n      const row = gameFieldCells[i];\n\n      for (let k = 0; k < row.length; k++) {\n        const value = field[i][k];\n        const cell = row[k];\n\n        cell.textContent = '';\n        cell.className = 'field-cell';\n\n        if (value) {\n          cell.textContent = value;\n          cell.className = `field-cell field-cell--${value}`;\n        }\n      }\n    }\n\n    if (maxCell === 2048) {\n      document.removeEventListener('keydown', kbListener);\n\n      messageWin.classList.remove('hidden');\n    }\n\n    if (!isAvailableMovement) {\n      document.removeEventListener('keydown', kbListener);\n      messageLose.classList.remove('hidden');\n    }\n  };\n\n  // #endregion\n\n  // #region keyboardListener\n\n  const kbListener = (e) => {\n    if (gStatus() === 'playing') {\n      changeButtonStartToRestart();\n    }\n\n    switch (e.key) {\n      case 'ArrowLeft':\n        game.moveLeft();\n        refreshGameField();\n        break;\n      case 'ArrowRight':\n        game.moveRight();\n        refreshGameField();\n        break;\n      case 'ArrowUp':\n        game.moveUp();\n        refreshGameField();\n        break;\n      case 'ArrowDown':\n        game.moveDown();\n        refreshGameField();\n        break;\n      default:\n        break;\n    }\n  };\n\n  // #endregion\n\n  startRestartButton.addEventListener('click', (e) => {\n    e.preventDefault();\n\n    const isResetButton = e.target.classList.contains('restart');\n    const isStartButton = e.target.classList.contains('start');\n\n    if (gStatus() === 'playing' && isResetButton) {\n      resetGame();\n      changeButtonRestartToStart();\n      document.addEventListener('keydown', kbListener);\n    }\n\n    if (gStatus() === 'playing' && isStartButton) {\n      resetGame();\n      refreshGameField();\n    }\n\n    if (gStatus() === 'idle' && isStartButton) {\n      game.start();\n\n      e.currentTarget.blur();\n\n      messageStart.classList.add('hidden');\n\n      refreshGameField();\n      document.addEventListener('keydown', kbListener);\n    }\n  });\n});\n"],"names":["$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","constructor","initialCustomState","direction","up","down","left","right","gameStatus","idle","playing","win","lose","initialField","score","cellMax","fieldSize","isAvailableMovement","status","isCustomInitial","defaultState","moveLeft","sumGameFieldByRow","moveRight","moveUp","sumGameFieldByColumn","moveDown","getScore","getState","state","getStatus","start","length","generateRandomCellOnField","restart","gMaxCell","getMoveAvailability","getMaxValueCell","gameField","Math","max","flat","getRandomCellValue","random","getRandomCellIndex","gameFieldSize","row","floor","col","sumRow","size","rtl","isSumm","sum","rightToLeftSum","reduceRight","newRow","value","i","firstValue","slice","Array","fill","summCollapsed","leftToRightSum","reduce","push","transposeField","field","newArr","forEach","item","itemIdx","compareGameField","array1","array2","array1Json","JSON","stringify","getAvailabilityMovement","sumOfCollapsedCells","includes","leftCollapsed","rightCollapsed","tr","upCollapsed","downCollapsed","scoreByField","calculatedGameField","map","rowCollaped","qty","parse","cell","cellValue","document","addEventListener","game","startRestartButton","querySelector","gStatus","gState","gScore","gIsAvailableMovement","messageStart","messageWin","messageLose","gameScore","rows","querySelectorAll","gameFieldCells","resetGame","refreshGameField","classList","add","changeButtonStartToRestart","remove","textContent","changeButtonRestartToStart","maxCell","k","className","removeEventListener","kbListener","e","key","preventDefault","isResetButton","target","contains","isStartButton","currentTarget","blur"],"version":3,"file":"index.b3e4f9bc.js.map"}